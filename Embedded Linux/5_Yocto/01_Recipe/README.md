# Recipe (.bb) Syntax

* Start by writing the header section using **local variables**. Set:
  * **SUMMARY**
  * **DESCRIPTION**
  * **LICENSE** with its cecksum files variable: **LIC_FILES_CHKSUM**
    * Those files are in `poky/meta/files/common-licenses` in the github of Yocto project

```sh
License = "MIT"         # is a must
LIC_FILES_CHKSUM = "file://...;md5=..."

#or make it closed
License = "closed"      # there is no need to set 'LIC_FILES_CHKSUM' here
```

## How to calculate checksum

* **First**, calculate the hash value of the license file.
  * Use `md5sum [file]` which is a shell command that uses a hash function to generate a hash value of the file given.

```shell
md5sum MIT              # calculates file checksum --> yields a hash value
```

* **Then**, write this value in `LIC_FILES_CHKSUM`

```sh
LIC_FILES_CHKSUM = "<schema>://[file location]; md5=[hash value]"
```

## What is "Schema"

* File is either located

  1. **locally** : on machine --> `file://[Absolute Path];md5=[hash value]`
  2. **in github** : ssh, https --> `git://[repo link];protocol=https;branch=main`
  3. **in https server**  : wget --> `https://[repo link]`

## `SRC_URI` Variable

* A local variable locates source code files and puts it into `Dounloads` directory **(DL)**.

## `SRC_REV` only with github

* If you want to checkout on a specific commit hash.

## Variables that hold directories' pathes

* `S` : **Source directory** of the recipe (unpacked files).
* `D` : **Destination directory** used by the package feeder.
* `B` : **Build directory** (compile).
* `WORKDIR` : `Top directory` that has **S**, **D**, and **B**.
* `FILEPATH` : tell the `SRC_URI` where to look for files. It's the last variable to be set after previous vars are set.

* These directories are automatically created by bitbake.

## Hidden Variables

* There are other local variables hidden in each recipe
  * `PV` : Package version
  * `PR` : Package release
  * `PN` : Package name

* How they are set?
  * They are set automatically by parsing the recipe name.

### How to name a recipe

* `[Package Name]_[package version]_[package release]`
* Those are got parsed into the hidden variables
* Example: `myrecipe_2.0_r3.bb`

## How to read the variable of a local variable?

```sh
bitbake -e recipe_name | grep variable
```

> `bitbake` is a Python code. When it takes the recipe as input, it creates Python commands from the variables in the file (including the hidden variables)
> `-e` : expand the recipe python code
> `bitbake` yields the executable on the target machine.

## `.bb` File Example

* **Note:** All variables defined in this recipe are local.

```sh
SUMMARY = "This is my recipe"
DESCRIPTION = "this recipe do nothing"

License = "MIT"
LIC_FILES_CHKSUM = "file://${COREBASE}/meta/files/common-license/MIT; md5=08..."
# 'COREBASE' variable has the absolute path to 'meta/'

# fetching the source from the (github, local, http server) 
SRC_URI = "git://github.com/...;protocol=https;branch=main"

# Checksum specific commit ONLY used in GIT
SRC_REV = "545845374537435458345388743145837453435"

# you could get it locally
SRC_URI = "file://main.c file://init"   #separate files using space
# Putting the file directly! It depends, it must be located in a specific place.
```

## Notes

* Use `bitbake -c cleanall recipe_name` to clean all recipe files.
* Use `bitbake -c listtasks` to list all tasks in the pyhton file generated by `bitbake` from the recipe.

* To run any task, use `bitbake -c task_name recipe_name`

* You can find the documentation of bitbake tasks in `meta/conf/documentation.conf`
* You can find what will be loaded in the root file system in `meta/conf/bitbake.conf`
* **Note:** Variables in those files are global, DO NOT EDIT THEM, as they are applied to all recipes
* Put your **Global** Variables in:
  * `local.conf`
* To get local vars using `bitbake`:
  * bitbake-getvar -r recipe_name variable
* In yocto, you just set some variables

* You put under your layer, the bsp layer and the applications layer
  * Yocto provides a reference of Beagle-bone in its meta-beaglebone-bsp layer.
  * You can aquire the bsp layers from the vendors github repos meta-board_name-bsp layer.

---

## Task

* Write a recipe to clone the repo app

```python
SUMMARY = "This is my recipe"
DESCRIPTION = "this recipe do nothing"

License = "MIT"
LIC_FILES_CHKSUM = "file://${COMMON_LICENSE_DIR}/MIT;md5=08..."

FILESPATH:append = " :${THISDIR}/ahmed:"

SRC_URI = "file://main.c"

inherit [something]

python do_configure(){
    # just use cmake (for x86) to build
    # in (rpbi) it's not cmake
    cmake -S . -B ${B}
}

do_compile () {
    # check how makefile are used in yocto
    make -C ${B}
}

do_install(){
    mkdir -p ${D}${bindir}
    cp ${B}/myapp ${D}${bindir}
}
```

---

## Tasks

* `do_fetch`
* `do_unpack`
* `do_patch`
* `do_configure`
* `do_compile`
* `do_install`

---

## `local.conf` file

* layer
  * 

```shell
Machine = ""  # from layer (BSP Layer)

```

## Other Variables

* `DEPENDS` : Recipes that your recipe depends on.
  * You can make your recipe depends on another recipe
    * takes the output of that recipe and puts it in the work directory of your recipe.
    * So, the recipe in `DEPENDS` build first, then your recipe.

>```shell
>DEPENDS = "recipe_add"
>```

* `PROVIDES` : Put it in the dependency recipe and put in it a chosen name/s as alias.
  * Then in your recipe : `DEPENDS = "that chosen name"`
  * You can put more than one name in the `DEPENDS` variable based on the dependencies recipes.

* These dependencies will be installed in the `rootfs` directory by installing your recipe.
  * So put every recipe -or their aliases- your recipe is depending on in `DEPENDS` then install just your recipe for these recipes to be installed.

